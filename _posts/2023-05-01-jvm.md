---
layout:     post
title:      "JVM"
author:     "Johnny"
header-style: text
catalog: false
published: true
tags:
    - JVM
    - Java
---

**什么是JVM？**Java虚拟机（JVM）是Java平台的核心组成部分，它负责将Java字节码翻译成特定操作系统或硬件平台的指令。它提供了内存管理、垃圾回收、线程管理等功能，使得Java程序可以在不同平台上运行。

**Java的内存结构是怎样的？** Java内存结构分为：方法区（Method Area）、堆（Heap）、栈（Stack）、本地方法栈（Native Method Stack）和程序计数器（Program Counter Register）。

**JVM的主要组成部分是什么？** JVM主要由三个组件组成：类加载器（Class Loader）、运行时数据区（Runtime Data Areas）和执行引擎（Execution Engine）。

**什么是类加载器？** 类加载器负责将类文件加载到JVM中。JVM中有三种类加载器：启动类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）和应用程序类加载器（Application Class Loader）。

**什么是Java堆？** Java堆是Java应用程序运行时数据区的一部分，用于存储对象实例。它是垃圾回收的主要区域，分为新生代（Young Generation）和老年代（Old Generation）。

它是被所有线程共享的一块内存区域，用于动态分配内存给新创建的对象。

**什么是方法区？** 方法区是用于存储类的信息、常量、静态变量、编译器优化后的代码等的区域。在JVM规范中，方法区被称为“非堆内存”。

**什么是垃圾回收？** 垃圾回收是指JVM自动管理内存，释放不再被引用的对象所占用的内存空间，以防止内存泄漏和资源浪费。

**JVM中的垃圾回收算法有哪些？** 常见的垃圾回收算法包括：标记-清除算法、复制算法、标记-整理算法和分代收集算法。分代收集算法是最常用的，它将堆分为不同的代，如新生代和老年代，并为它们选择合适的回收算法。

**什么是类加载？** 类加载是指在JVM中将类的字节码从磁盘加载到内存，并进行解析和初始化的过程。类加载器（ClassLoader）负责执行这个过程。

**Java中的哪些对象会被认为是可垃圾回收的？** 可被垃圾回收的对象是那些不再被任何活跃的引用所指向的对象。这包括没有被任何变量引用的对象和被循环引用的对象。

**MinorGC，MajorGC、FullGC都什么时候发生？**

1. Minor GC（新生代GC）： Minor GC发生在新生代（Young Generation）内存区域。新生代通常分为一个较小的Eden空间和两个较小的Survivor空间（通常称为S0和S1）。当对象被创建时，它们首先被分配到Eden空间，随着时间的推移，部分存活的对象会被移到Survivor空间。Minor GC的触发条件通常是Eden空间满或者其中一个Survivor空间满。在Minor GC中，不再存活的对象会被回收，存活的对象会被复制到另一个Survivor空间。
2. Major GC（Old GC）： Major GC（或Old GC）发生在老年代（Old Generation）内存区域。老年代存放着较长寿命的对象，通常是从新生代晋升而来的对象。Major GC的触发条件通常包括老年代空间占用达到一定阈值、永久代（在早期Java版本中）或元空间占用达到一定阈值等。Major GC的开销通常比Minor GC更高，因为它需要检查和清理老年代中的对象，可能涉及较长的停顿时间。
3. Full GC（完全垃圾回收）： Full GC 是对整个堆内存（包括年轻代和老年代）的垃圾回收。它会清理整个堆内存中的无用对象，包括年轻代和老年代。Full GC 的开销通常是最大的，因为它会涉及到整个堆内存的扫描和清理，因此可能会导致较长的应用程序停顿。

**生产环境服务器变慢，如何诊断处理？**

**1、** 使用 top 指令，服务器中 CPU 和 内存的使用情况，-H 可以按 CPU 使用率降序，-M 内存使用率降序。排除其他进程占用过高的硬件资源，对 Java 服务造成影响。

**2、** 如果发现 CPU 使用过高，可以使用 top 指令查出 JVM 中占用 CPU 过高的线程，通过 jstack 找到对应的线程代码调用，排查出问题代码。

**3、** 如果发现内存使用率比较高，可以 dump 出 JVM 堆内存，然后借助 MAT 进行分析，查出大对象或者占用最多的对象来自哪里，为什么会长时间占用这么多；如果 dump 出的堆内存文件正常，此时可以考虑堆外内存被大量使用导致出现问题，需要借助操作系统指令 pmap 查出进程的内存分配情况、gdb dump 出具体内存信息、perf 查看本地函数调用等。

**4、** 如果 CPU 和 内存使用率都很正常，那就需要进一步开启 GC 日志，分析用户线程暂停的时间、各部分内存区域 GC 次数和时间等指标，可以借助 jstat 或可视化工具 GCeasy 等，如果问题出在 GC 上面的话，考虑是否是内存不够、根据垃圾对象的特点进行参数调优、使用更适合的垃圾收集器；分析 jstack 出来的各个线程状态。如果问题实在比较隐蔽，考虑是否可以开启 jmx，使用 visualmv 等可视化工具远程监控与分析。
